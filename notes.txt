============ readline ============
#include <stdio.h>
#include <readline/readline.h>
#include <readline/history.h>
char *        readline (const char *prompt);
The line returned is allocated with malloc(3); the caller must free it when
finished. The line returned has the final newline removed, so only the text of
the line remains.

============ rl_clear_history ============
void rl_clear_history (void)
Clear the history list by deleting all of the entries, in the same manner as the
History library's clear_history() function. This differs from clear_history
because it frees private data Readline saves in the history list.

============ rl_on_new_line ============
int rl_on_new_line ()
Tell the update routines that we have moved onto a new (empty) line, usually
after ouputting a newline.

============ rl_replace_line ============
void rl_replace_line (const char *text, int clear_undo)
Replace the contents of rl_line_buffer (le contenu courant du tampon de ligne)
with text. The point and mark are preserved, if possible. If clear_undo is
non-zero, the undo list associated with the current line is cleared.

============ rl_redisplay ============
void rl_redisplay (void)
Change what's displayed on the screen to reflect the current contents of
rl_line_buffer.

============ add_history ============
void add_history (const char *string)
Place string at the end of the history list. The associated data field (if any)
is set to NULL.

============ access ============
#include <unistd.h>
int access(const char *pathname, int mode);
access() vérifie si le processus appelant peut accéder au fichier pathname. Si
pathname est un lien symbolique, il est déréférencé.
Le mode indique la (les) vérification(s) d'accessibilité à effectuer (F_OK,
R_OK, W_OK, X_OK).
L'appel renvoie 0 s'il réussit (toutes les requêtes sont autorisées), ou -1 s'il
échoue (au moins une requête du mode est interdite), auquel cas errno contient
le code d'erreur.

============ fork ============
#include <unistd.h>
pid_t fork(void);
Causes creation of a new process. The child process has its own copy of the
parent's descriptors. But these descriptors reference the same underlying
objects : an lseek on a descriptor in the child process can affect a subsequent
read or write by the parent. Returns 0 to the child process and the process ID
of the child to the parent.

============ wait ============
#include <sys/wait.h>
pid_t wait(int *stat_loc);
If wait() returns due to a stopped or terminated child process, the process ID
of the child is returned to the calling process.  Otherwise, a value of -1 is
returned and errno is set to indicate the error.

============ wait4 ============
pid_t wait4(pid_t pid, int *stat_loc, int options, struct rusage *rusage);
Provides a more general interface for programs that need to wait for certain
child processes, that need resource utilization statistics accumulated by child
processes, or that require options.
If pid is -1, the call waits for any child process. If pid is 0, the call waits
for any child process in the process group of the caller.
If pid is less than -1, the call waits for any process whose process group id
equals the absolute value of pid.
If wait3(), wait4(), or waitpid() returns due to a stopped or terminated child
process, the process ID of the child is returned to the calling process.
If there are no children not previously awaited, -1 is returned with errno set
to [ECHILD].  Otherwise, ...

============ waitpid ============
pid_t waitpid(pid_t pid, int *stat_loc, int options);
The waitpid() call is identical to wait4() with an rusage value of zero.

============ wait3 ============
pid_t wait3(int *stat_loc, int options, struct rusage *rusage);
The older wait3() call is the same as wait4() with a pid value of -1.

============ signal ============
#include <signal.h>
void (*signal(int sig, void (*func)(int)))(int);
Simplified interface to the more general sigaction(2).
The previous action is returned on a successful call.
When a process which has installed signal handlers forks, the child process
inherits the signals.

============ sigaction ============
int sigaction(int sig, const struct sigaction *restrict act,
	struct sigaction *restrict oact);
After a fork(2) or vfork(2) all signals, the signal mask, the signal stack, and
the restart/interrupt flags are inherited by the child.
The sigaction() function returns the value 0 if successful; otherwise the value
-1 is returned.

============ kill ============
int kill(pid_t pid, int sig);
A value of 0 causes error checking to be performed (with no signal being sent).

============ exit ============
#include <stdlib.h>
void exit(int status);
Flush all open output streams, close all open streams.

============ getcwd ============
#include <unistd.h>
char *getcwd(char *buf, size_t size);
Copies the absolute pathname of the current working directory into the memory
referenced by buf and returns a pointer to buf.  The size argument is the
size, in bytes, of the array referenced by buf.
Returns NULL in case of error.

============ chdir ============
#include <unistd.h>
int chdir(const char *path);
Success returns 0, otherwise -1.

============ stat ============
#include <sys/stat.h>
int stat(const char *restrict path, struct stat *restrict buf);
Obtains information about the file pointed to by path. In case of symlinks:
returns info about the file the link references.

============ lstat ============
int lstat(const char *restrict path, struct stat *restrict buf);
In the case where the named file is a symbolic link; lstat() returns information
about the link.

============ fstat ============
int fstat(int fildes, struct stat *buf);
The fstat() obtains the same information about an open file known by the file
descriptor fildes.

============ unlink ============
#include <unistd.h>
int unlink(const char *path);
The unlink() function removes the link named by path from its directory and
decrements the link count of the file which was referenced by the link.
Upon successful completion, a value of 0 is returned.  Otherwise, -1.

============ execve ============
#include <unistd.h>
int execve(const char *path, char *const argv[], char *const envp[]);
execve() transforms the calling process into a new process. The new process is
constructed from an ordinary file, whose name is pointed to by path.
If any optional args are specified, they become the first (& more) argument to
the interpreter.
The execve(2) system call reinstates the default action for all signals which
were caught and resets all signals to be caught on the user stack.  Ignored
signals remain ignored; the signal mask remains the same; signals that restart
pending system calls continue to do so.

============ dup ============
#include <unistd.h>
int dup(int fildes);
dup() duplicates an existing object descriptor and returns its value.
read(2), write(2) and lseek(2) calls all move a single pointer into the file,
and append mode, non-blocking I/O and asynchronous I/O options are shared
between the references.
If a separate pointer into the file is desired, a different object reference
to the file must be obtained by issuing an additional open(2) call.
-1 is returned in case of error.

============ dup2 ============
int dup2(int fildes, int fildes2);
In dup2(), the value of the new descriptor fildes2 is specified.
-1 is returned in case of error.

============ pipe ============
#include <unistd.h>
int pipe(int fildes[2]);
The pipe() function creates a pipe (an object that allows unidirectional data
flow) and allocates a pair of file descriptors. [0 : read, 1 : write]
Returns 0 on success, -1 in case of issue.

============ opendir ============
#include <dirent.h>
DIR *opendir(const char *filename);
The opendir() function opens the directory named by filename, associates a
directory stream with it and returns a pointer to be used to identify the
directory stream in subsequent operations.
Returns a NULL pointer in case of issue.

============ readdir ============
int readdir_r(DIR *dirp, struct dirent *entry, struct dirent **result);
The readdir() function returns a pointer to the next directory entry.  It
returns NULL upon reaching the end of the directory or on error.

============ closedir ============
int closedir(DIR *dirp);

============ strerror ============
#include <stdio.h>
char *strerror(int errnum);
Look up the error message string corresponding to an error number.

============ perror ============
void perror(const char *str);
The perror() function finds the error message corresponding to the current
value of the global variable errno (intro(2)) and writes it, followed by a
newline, to the standard error file descriptor.
str will be appended at the beginning of the error message followed by ': '.

============ isatty ============
#include <unistd.h>
int isatty(int fd);
Determines if the file descriptor fd refers to a valid terminal type device.
If yes, returns 1. Else, returns 0.

============ ttyname ============
char *ttyname(int fd);
Gets the related device name of a file descriptor for which isatty() is true.
Returns the null terminated name if the device is found and isatty() is true;
otherwise a NULL pointer is returned.

============ ttyslot ============
#include <unistd.h>
int ttyslot(void);
Returns the index of the current user's entry in some file.
<=>
Renvoie l'index du terminal de contrôle du processus appelant dans le fichier
/etc/ttys, qui est aussi (en principe) l'index de l'entrée pour l'utilisateur
en cours dans le fichier /etc/utmp
Comme les systèmes Linux n'ont habituellement pas de /etc/ttys,
elle renverra toujours 0.

============ ioctl ============
#include <sys/ioctl.h>
int ioctl(int fildes, unsigned long request, ...);
The argument fildes must be an open file descriptor.
It manipulates the underlying device parameters of special files (terminals).
If an error has occurred, a value of -1 is returned.

============ getenv ============
#include <stdlib.h>
char * getenv(const char *name);
Obtains the current value of the environment variable, name.
If the variable name is not in the current environment, NULL is returned.

============ tcsetattr ============
#include <termios.h>
#include <unistd.h>
int
 tcsetattr(int fildes, int optional_actions, const struct termios *termios_p);
The termios functions describe a general terminal interface that is provided to
control asynchronous communications ports.

============ tcgetattr ============
int tcgetattr(int fd, struct termios *termios_p);

============ tgetent ============
#include <curses.h>
#include <term.h>
int tgetent(char *bp, const char *name);
The tgetent routine loads the entry for name. It returns 1 on success, 0 if
there is no such entry, and -1 if the terminfo database could not be found.
The emulation ignores the buffer pointer bp.

============ tgetflag ============
int tgetflag(char *id);
The tgetflag routine gets the boolean entry for id, or zero if it is not
available.

============ tgetnum ============
int tgetnum(char *id);
The tgetnum routine gets the numeric entry for id, or -1 if it is not
available.

============ tgetstr ============
char *tgetstr(char *id, char **area);
Returns the string entry for id, or zero if it is not available.

============ tgoto ============
char *tgoto(const char *cap, int col, int row);
The tgoto routine instantiates the parameters into the given capability.
The output from this routine is to be passed to tputs.

============ tputs ============
int tputs(const char *str, int affcnt, int (*putc)(int));
Use tputs to output the returned string.
The tputs routine is described on the curs_terminfo(3X) manual page. It can
retrieve capabilities by either termcap or terminfo name.

https://velog.io/@du0928/Minishell
https://viewsourcecode.org/snaptoken/kilo/01.setup.html
https://www.cs.purdue.edu/homes/grr/SystemsProgrammingBook/Book/Chapter5-WritingYourOwnShell.pdf
http://i.paysdu42.fr/?page=minishell.c
https://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html
https://github.55860.com/topics/minishell
https://githubmemory.com/repo/maxime-42/minishell



head -1 fichier >       head -1     | head -1
__________________________________   _______
s_cmd                                s_cmd


([,1-9]*) byte([\s\S]*)


https://github.com/Binary-Hackers/42_Corrections/blob/master/00_Projects/01_Unix/minishell/00.pdf
